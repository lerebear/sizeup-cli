/* eslint-disable perfectionist/sort-classes */
import {Args, Command, Flags, ux} from '@oclif/core'
import * as fs from 'node:fs'
import * as path from 'node:path'
import * as StreamZip from 'node-stream-zip'
import {Octokit} from 'octokit'

const TMP_DIR = '/tmp/sizeup'

type Format = 'csv' | 'json'

export default class Aggregate extends Command {
  static args = {
    repository: Args.string({
      description: 'The repository from which we should aggregate data',
      required: true,
    }),
    // eslint-disable-next-line perfectionist/sort-objects
    output: Args.string({
      description: 'Path to file where the output of this command should be written',
      required: true,
    }),
    // eslint-disable-next-line perfectionist/sort-objects
    lookback: Args.string({
      default: '1mo',
      description: (
        'The lookback period over which to aggregate data e.g. "4d", "10w", "3mo"'
      ),
      required: false,
    }),
  }

  static description = 'Aggregate data generated by `sizeup-action`'

  static examples = [
    {
      command: '<%= config.bin %> aggregate lerebear/sizeup-core data.csv',
      description: "Aggregate the last month's worth of data generated by https://github.com/lerebear/sizeup-core",
    },
    {
      command: '<%= config.bin %> aggregate lerebear/sizeup-core data.csv 1w',
      description: "Aggregate the last week's worth of data generated by https://github.com/lerebear/sizeup-core",
    },
  ]

  static flags = {
    clean: Flags.boolean({
      char: 'c',
      default: false,
      description: 'Clear the cache of previously downloaded artifacts before downloading new ones',
      required: false,
    }),
    format: Flags.custom<Format>({
      char: 'f',
      default: 'csv',
      description: 'The format with which the `sizeup-action` artifacts were generated',
      required: false,
    })(),
    'token-path': Flags.string({
      char: 't',
      description: 'Path to a file containing a GitHub API token.\n'
       + 'If this flag is omitted then the tool will prompt for a token instead.',
      required: false,
    }),
  }

  static strict = false

  async run(): Promise<void> {
    const {args, flags} = await this.parse(Aggregate)
    const lookback = this.getLookbackInDays(args.lookback)
    if (!lookback) return

    this.log(`Aggregating data from ${args.repository} for the past ${lookback === 1 ? '24 hours' : `${lookback} days`}`)

    const artifacts = await this.downloadArtifacts(args.repository, lookback, flags['token-path'], flags.clean)
    await this.aggregateArtifacts(artifacts, flags.format, args.output)

    this.log(`Aggregated ${artifacts.length} ${flags.format} ${artifacts.length === 1 ? 'file' : 'files'} in ${args.output}`)
  }

  private async downloadArtifacts(repository: string, lookback: number, tokenPath: string | undefined, clean: boolean): Promise<string[]> {
    const token = tokenPath
      ? fs.readFileSync(tokenPath).toString().trim()
      : await ux.prompt('Please enter a GitHub API token', {type: 'hide'})

    const cutoff = new Date()
    cutoff.setDate(cutoff.getDate() - lookback)

    ux.action.start('Downloading artifacts')

    const octokit = new Octokit({auth: token})
    const [owner, repo] = repository.split('/')
    const artifacts = await octokit.paginate(octokit.rest.actions.listArtifactsForRepo, {
      name: 'sizeup-score',
      owner,
      // eslint-disable-next-line camelcase
      per_page: 100,
      repo,
    }, (response, done) => {
      if (response.data.some(a => new Date(a.created_at!) < cutoff)) {
        done()
      }

      return response.data
    })

    if (clean) {
      fs.rmSync(TMP_DIR, {force: true, recursive: true})
    }

    if (!fs.existsSync(TMP_DIR)) {
      fs.mkdirSync(TMP_DIR)
    }

    const downloads = []
    const fileNames = []

    for (const artifact of artifacts.filter(a => new Date(a.created_at!) >= cutoff && !a.expired)) {
      const timestamp = (new Date(artifact.created_at!)).getTime()
      const filename = path.resolve(TMP_DIR, `./${timestamp}-${artifact.id}.zip`)

      fileNames.push(filename)
      if (fs.existsSync(filename)) {
        continue
      }

      downloads.push(
        octokit.rest.actions.downloadArtifact({
          // eslint-disable-next-line camelcase
          archive_format: 'zip',
          // eslint-disable-next-line camelcase
          artifact_id: artifact.id,
          owner,
          repo,
        }).then(response => fs.writeFileSync(filename, Buffer.from(response.data as ArrayBuffer))),
      )
    }

    await Promise.all(downloads)
    ux.action.stop()

    return fileNames
  }

  private getLookbackInDays(lookback: string): number | undefined {
    const match = lookback && lookback.match(/(?<duration>\d+)(?<unit>d|w|mo|y)/)
    if (!match) {
      this.log('Invalid lookback format')
      return
    }

    let lookbackInDays = Number.parseInt(lookback ? match.groups!.duration : '30', 10)

    switch (match.groups!.unit) {
      case 'w': {
        lookbackInDays *= 7
        break
      }

      case 'mo': {
        lookbackInDays *= 30
        break
      }

      case 'y': {
        lookbackInDays *= 365
        break
      }

      default: {
        break
      }
    }

    return lookbackInDays
  }

  private async aggregateArtifacts(artifacts: string[], format: 'csv' | 'json', outputFile: string): Promise<void> {
    ux.action.start('Unpacking artifacts')

    const output = fs.createWriteStream(outputFile)
    let writeCsvHeader = format === 'csv'

    for (const artifact of artifacts) {
      // eslint-disable-next-line new-cap, import/namespace
      const zip = new StreamZip.async({file: artifact})
      // eslint-disable-next-line no-await-in-loop
      const buffer = await zip.entryData(`sizeup-score/sizeup-score.${format}`)

      if (format === 'json' || writeCsvHeader) {
        output.write(buffer.toString().trim() + '\n')
        writeCsvHeader = false
      } else {
        output.write(buffer.toString().trim().split('\n')[1] + '\n')
      }

      // eslint-disable-next-line no-await-in-loop
      await zip.close()
    }

    output.end()
    ux.action.stop()
  }
}
